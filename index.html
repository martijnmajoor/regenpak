<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cycling Route Weather</title>
    <style>
      #map {
        height: 400px;
        width: 100%;
        margin: 20px 0;
      }
      .route-step {
        margin: 20px 0;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      .marker-label {
        position: absolute;
        background-color: white;
        border-radius: 50%;
        padding: 5px 10px;
        font-size: 14px;
        font-weight: bold;
        color: black;
        border: 1px solid black;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <h1>Cycling Route Weather</h1>
    <form id="route-form">
      <label for="from">Address From:</label>
      <input type="text" id="from" name="from" required /><br />

      <label for="to">Address To:</label>
      <input type="text" id="to" name="to" required /><br />

      <label for="departure-time">Departure Time:</label>
      <input
        type="datetime-local"
        id="departure-time"
        name="departure-time"
        required
      /><br />

      <label for="speed">Cycling Speed:</label>
      <select id="speed" name="speed">
        <option value="leisurely">Leisurely (&lt;20 km/h)</option>
        <option value="active">Active (20-25 km/h)</option>
        <option value="racing">Racing/Electric (&gt;25 km/h)</option></select
      ><br />

      <label for="google-api-key">Google Maps API Key:</label>
      <input
        type="text"
        id="google-api-key"
        name="google-api-key"
        required
      /><br />

      <label for="openweather-api-key">OpenWeather API Key:</label>
      <input
        type="text"
        id="openweather-api-key"
        name="openweather-api-key"
        required
      /><br />

      <label for="map-id">Google Maps Map ID:</label>
      <input
        type="text"
        id="map-id"
        name="map-id"
        placeholder="Enter Map ID"
        required
      /><br />

      <button type="submit">Get Route</button>
    </form>

    <div id="map"></div>
    <div id="route-output"></div>

    <script>
      let map;
      let markers = [];
      let polyline;
      let googleMapsLoaded = false;

      document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("from").value =
          localStorage.getItem("from") || "";
        document.getElementById("to").value = localStorage.getItem("to") || "";
        document.getElementById("speed").value =
          localStorage.getItem("cycling-speed") || "leisurely";

        const now = new Date();
        document.getElementById("departure-time").value = now
          .toISOString()
          .slice(0, 16);
      });

      document
        .getElementById("route-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          try {
            const googleApiKey =
              document.getElementById("google-api-key").value;
            const openWeatherApiKey = document.getElementById(
              "openweather-api-key",
            ).value;
            const from = document.getElementById("from").value;
            const to = document.getElementById("to").value;
            const departureTime = new Date(
              document.getElementById("departure-time").value,
            );
            const speed = document.getElementById("speed").value;
            const mapId = document.getElementById("map-id").value;

            if (!mapId) {
              alert("Map ID is required to enable Advanced Markers.");
              return;
            }

            localStorage.setItem("from", from);
            localStorage.setItem("to", to);
            localStorage.setItem("cycling-speed", speed);

            if (!googleMapsLoaded) {
              await loadGoogleMapsAPI(googleApiKey, mapId);
            }

            const route = await getRoute(from, to);
            const weatherData = await getWeatherForRoute(
              route,
              departureTime,
              speed,
              openWeatherApiKey,
            );
            displayRouteOnMap(route, weatherData);
            displayRouteDetails(weatherData);
          } catch (error) {
            console.error("Error:", error);
            alert(`Error: ${error.message}`);
          }
        });

      async function loadGoogleMapsAPI(apiKey, mapId) {
        if (googleMapsLoaded) return;

        return new Promise((resolve, reject) => {
          // Create a callback function before loading the script
          window.initMap = () => {
            try {
              map = new google.maps.Map(document.getElementById("map"), {
                zoom: 12,
                center: { lat: 0, lng: 0 },
                mapId: mapId,
                // Add WebGL optimization settings
                renderingType: "UNINITIALIZED",
                webglContextAttributes: {
                  antialias: true,
                  powerPreference: "high-performance",
                },
              });
              googleMapsLoaded = true;
              resolve();
            } catch (error) {
              reject(error);
            }
          };

          // Create loading script element
          const script = document.createElement("script");
          const url = new URL("https://maps.googleapis.com/maps/api/js");
          url.searchParams.append("key", apiKey);
          url.searchParams.append("callback", "initMap");
          url.searchParams.append("libraries", "geometry,marker");
          url.searchParams.append("v", "weekly");
          url.searchParams.append("map_ids", mapId);

          script.src = url.toString();
          script.async = true;
          script.defer = true;
          script.onerror = reject;

          // Add script to document
          document.head.appendChild(script);
        });
      }

      function clearMap() {
        markers.forEach((marker) => marker.setMap(null));
        markers = [];
        if (polyline) {
          polyline.setMap(null);
        }
      }

      async function getRoute(from, to) {
        return new Promise((resolve, reject) => {
          const directionsService = new google.maps.DirectionsService();
          const request = {
            origin: from,
            destination: to,
            travelMode: google.maps.TravelMode.BICYCLING,
          };

          directionsService.route(request, (result, status) => {
            if (status === "OK") {
              resolve(result.routes[0].legs[0].steps);
            } else {
              reject(new Error(`Failed to get route: ${status}`));
            }
          });
        });
      }

      async function getWeatherForRoute(
        route,
        departureTime,
        speed,
        openWeatherApiKey,
      ) {
        const weatherResults = [];
        const weatherCheckInterval = 5 * 60 * 1000;

        const speedValues = {
          leisurely: 20 / 3.6,
          active: 25 / 3.6,
          racing: 30 / 3.6,
        };
        const selectedSpeed = speedValues[speed] || 20 / 3.6;

        let accumulatedTime = 0;
        let currentTime = departureTime.getTime();
        let lastMarkerTime = currentTime;

        weatherResults.push({
          position: route[0].start_location,
          weather: "Starting point",
          windEffect: "Unknown",
          arrivalTime: new Date(currentTime),
          distance: 0,
          step: route[0],
        });

        for (let i = 0; i < route.length - 1; i++) {
          const startPoint = route[i];
          const endPoint = route[i + 1];

          const distanceBetweenPoints =
            google.maps.geometry.spherical.computeDistanceBetween(
              startPoint.start_location,
              endPoint.start_location,
            );

          const travelTime = (distanceBetweenPoints / selectedSpeed) * 1000;

          accumulatedTime += travelTime;

          const arrivalTime = new Date(lastMarkerTime + accumulatedTime);

          if (accumulatedTime >= weatherCheckInterval) {
            try {
              const timestamp = Math.floor(arrivalTime.getTime() / 1000);
              const weatherResponse = await fetch(
                `https://api.openweathermap.org/data/2.5/onecall?lat=${endPoint.start_location.lat()}&lon=${endPoint.start_location.lng()}&dt=${timestamp}&appid=${openWeatherApiKey}`,
              );

              if (!weatherResponse.ok) {
                throw new Error(`Weather API error: ${weatherResponse.status}`);
              }

              const weatherData = await weatherResponse.json();

              if (!weatherData || !weatherData.current) {
                throw new Error("Invalid weather data received");
              }

              weatherResults.push({
                position: endPoint.start_location,
                weather: weatherData.current.weather[0].description,
                windEffect: determineWindEffect(
                  weatherData.current.wind_deg,
                  selectedSpeed,
                ),
                arrivalTime: arrivalTime,
                distance: accumulatedTime / 1000,
                step: endPoint,
              });

              lastMarkerTime = arrivalTime.getTime();
              accumulatedTime = 0;
            } catch (error) {
              console.error("Weather API error:", error);
              weatherResults.push({
                position: endPoint.start_location,
                weather: "Weather data unavailable",
                windEffect: "Unknown",
                arrivalTime: arrivalTime,
                distance: accumulatedTime / 1000,
                step: endPoint,
              });

              lastMarkerTime = arrivalTime.getTime();
              accumulatedTime = 0;
            }
          }
        }

        const finalPoint = route[route.length - 1];
        const finalArrivalTime = new Date(lastMarkerTime + accumulatedTime);

        weatherResults.push({
          position: finalPoint.start_location,
          weather: "Destination reached",
          windEffect: "Unknown",
          arrivalTime: finalArrivalTime,
          distance: accumulatedTime / 1000,
          step: finalPoint,
        });

        return weatherResults;
      }

      function determineWindEffect(windDeg, cyclingDirection) {
        const angleDiff = Math.abs(windDeg - cyclingDirection);

        if (angleDiff <= 30 || angleDiff >= 330) {
          return "Tailwind ✅";
        } else if (angleDiff >= 150 && angleDiff <= 210) {
          return "Headwind 🆘";
        } else {
          return "Crosswind 🌬️";
        }
      }

      function displayRouteOnMap(route, weatherData) {
        clearMap();

        const path = [];
        route.forEach((step) => {
          if (step.path) {
            path.push(...step.path);
          } else {
            path.push(step.start_location);
          }
        });
        if (route.length > 0) {
          path.push(route[route.length - 1].end_location);
        }

        polyline = new google.maps.Polyline({
          path: path,
          geodesic: true,
          strokeColor: "#FF0000",
          strokeOpacity: 1.0,
          strokeWeight: 2,
          map: map,
        });

        weatherData.forEach((point, index) => {
          const marker = new google.maps.marker.AdvancedMarkerElement({
            position: point.position,
            map: map,
            title: `Weather Checkpoint ${index + 1}`,
          });

          const customLabel = new google.maps.OverlayView();
          customLabel.onAdd = function () {
            const label = document.createElement("div");
            label.classList.add("marker-label");
            label.innerText = (index + 1).toString();
            this.getPanes().overlayLayer.appendChild(label);

            this.draw = function () {
              const position = this.getProjection().fromLatLngToDivPixel(
                marker.position,
              );
              label.style.left = `${position.x - label.offsetWidth / 2}px`;
              label.style.top = `${position.y - label.offsetHeight / 2}px`;
            };
          };
          customLabel.setMap(map);

          const infoWindow = new google.maps.InfoWindow({
            content: `
        <div>
          <p><strong>Time:</strong> ${point.arrivalTime.toLocaleTimeString()}</p>
          <p><strong>Weather:</strong> ${point.weather}</p>
          <p><strong>Wind Effect:</strong> ${point.windEffect}</p>
          <p><strong>Distance:</strong> ${(point.distance / 1000).toFixed(2)} km</p>
        </div>
      `,
          });

          marker.addListener("click", () => {
            infoWindow.open(map, marker);
          });

          markers.push(marker);
        });

        // Move map to first marker after it's rendered
        if (markers.length > 0) {
          map.panTo(markers[0].position); // Use `position` directly
          map.setZoom(14); // Optional: adjust zoom level as needed
        }
      }

      function displayRouteDetails(weatherData) {
        const output = document.getElementById("route-output");
        output.innerHTML = "";

        weatherData.forEach((point, index) => {
          const stepDiv = document.createElement("div");
          stepDiv.classList.add("route-step");
          stepDiv.innerHTML = `
            <h3>Checkpoint ${index + 1}</h3>
            <p><strong>Time:</strong> ${point.arrivalTime.toLocaleTimeString()}</p>
            <p><strong>Weather:</strong> ${point.weather}</p>
            <p><strong>Wind Effect:</strong> ${point.windEffect}</p>
            <p><strong>Distance:</strong> ${(point.distance / 1000).toFixed(2)} km</p>
          `;
          output.appendChild(stepDiv);
        });
      }
    </script>
  </body>
</html>
