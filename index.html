<!doctype html>
<html lang="en">
  <!-- Previous head section remains the same -->
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cycling Route Weather</title>
    <style>
      .route-step {
        margin: 20px 0;
        padding: 20px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background-color: #f9f9f9;
      }
      .route-step h3 {
        margin-top: 0;
        color: #333;
      }
      .checkpoint-number {
        display: inline-block;
        background-color: #007bff;
        color: white;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        text-align: center;
        line-height: 24px;
        margin-right: 10px;
      }
      .risk-high {
        background-color: #ffebee;
        border-color: #ef5350;
      }
      .risk-moderate {
        background-color: #fff3e0;
        border-color: #ff9800;
      }
      .ice-warning {
        margin-top: 10px;
        padding: 8px;
        border-radius: 4px;
        font-weight: bold;
      }
      .risk-high .ice-warning {
        background-color: #ef5350;
        color: white;
      }
      .risk-moderate .ice-warning {
        background-color: #ff9800;
        color: white;
      }
      .weather-point {
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 0.5rem;
      }
      .weather-icon {
        font-size: 1.5rem;
        cursor: help;
      }
      .black-ice-warning {
        color: #ff4444;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <!-- Previous HTML form remains the same -->
    <h1>Cycling Route Weather</h1>
    <form id="route-form">
      <label for="from">Address From:</label>
      <input type="text" id="from" name="from" required /><br />

      <label for="to">Address To:</label>
      <input type="text" id="to" name="to" required /><br />

      <label for="departure-time">Departure Time:</label>
      <input
        type="datetime-local"
        id="departure-time"
        name="departure-time"
        required
      /><br />

      <label for="speed">Cycling Speed:</label>
      <select id="speed" name="speed">
        <option value="leisurely">Leisurely (&lt;20 km/h)</option>
        <option value="active">Active (20-25 km/h)</option>
        <option value="racing">Racing/Electric (&gt;25 km/h)</option></select
      ><br />

      <label for="google-api-key">Google Maps API Key:</label>
      <input
        type="text"
        id="google-api-key"
        name="google-api-key"
        required
      /><br />

      <label for="openweather-api-key">OpenWeather API Key:</label>
      <input
        type="text"
        id="openweather-api-key"
        name="openweather-api-key"
        required
      /><br />

      <button type="submit">Get Route</button>
    </form>

    <div id="route-output"></div>

    <script>
      let googleMapsLoaded = false;

      // Previous event listeners and initialization code remains the same
      document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("from").value =
          localStorage.getItem("from") || "";
        document.getElementById("to").value = localStorage.getItem("to") || "";
        document.getElementById("speed").value =
          localStorage.getItem("cycling-speed") || "leisurely";

        const now = new Date();
        document.getElementById("departure-time").value = now
          .toISOString()
          .slice(0, 16);
      });

      document
        .getElementById("route-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          try {
            const googleApiKey =
              document.getElementById("google-api-key").value;
            const openWeatherApiKey = document.getElementById(
              "openweather-api-key",
            ).value;
            const from = document.getElementById("from").value;
            const to = document.getElementById("to").value;
            const departureTime = new Date(
              document.getElementById("departure-time").value,
            );
            const speed = document.getElementById("speed").value;

            localStorage.setItem("from", from);
            localStorage.setItem("to", to);
            localStorage.setItem("cycling-speed", speed);

            if (!googleMapsLoaded) {
              await loadGoogleMapsAPI(googleApiKey);
            }

            const route = await getRoute(from, to);
            const weatherData = await getWeatherForRoute(
              route,
              departureTime,
              speed,
              openWeatherApiKey,
            );
            displayRouteDetails(weatherData);
          } catch (error) {
            console.error("Error:", error);
            alert(`Error: ${error.message}`);
          }
        });

      // Previous API loading and route fetching functions remain the same
      async function loadGoogleMapsAPI(apiKey) {
        if (googleMapsLoaded) return;

        return new Promise((resolve, reject) => {
          const script = document.createElement("script");
          const url = new URL("https://maps.googleapis.com/maps/api/js");
          url.searchParams.append("key", apiKey);
          url.searchParams.append("libraries", "geometry");
          url.searchParams.append("v", "weekly");

          script.src = url.toString();
          script.async = true;
          script.defer = true;
          script.onerror = reject;

          script.onload = () => {
            googleMapsLoaded = true;
            resolve();
          };

          document.head.appendChild(script);
        });
      }

      function extractLocationName(instructions) {
        if (!instructions) return null;

        // Remove HTML tags
        instructions = instructions.replace(/<[^>]*>/g, "");

        // List of phrases to remove from the beginning
        const phrasesToRemove = [
          /^Head [a-z]+ on /i,
          /^Turn [a-z]+ onto /i,
          /^Turn [a-z]+ to stay on /i,
          /^Continue onto /i,
          /^Take the /i,
          /^Use the /i,
          /^Make a U-turn at /i,
          /^Slight [a-z]+ onto /i,
          /^Sharp [a-z]+ onto /i,
          /^Turn [a-z]+ at /i,
          /^Exit the roundabout onto /i,
          /^Enter the roundabout and /i,
          /^At the roundabout, /i,
        ];

        // Remove each phrase if found at the start
        phrasesToRemove.forEach((phrase) => {
          instructions = instructions.replace(phrase, "");
        });

        // If after cleaning we're left with just directional instructions, return null
        if (
          /^(Slight|Sharp|Turn|Head|Continue|Use|Take|Make|Enter|Exit) /.test(
            instructions,
          )
        ) {
          return null;
        }

        return instructions.trim();
      }

      async function getRoute(from, to) {
        return new Promise((resolve, reject) => {
          const directionsService = new google.maps.DirectionsService();
          const request = {
            origin: from,
            destination: to,
            travelMode: google.maps.TravelMode.BICYCLING,
          };

          directionsService.route(request, (result, status) => {
            if (status === "OK") {
              resolve(result.routes[0].legs[0].steps);
            } else {
              reject(new Error(`Failed to get route: ${status}`));
            }
          });
        });
      }

      function calculateBlackIceRisk(weatherData) {
        // Risk factors and their weights (0-1)
        const RISK_WEIGHTS = {
          temperature: 0.3,
          precipitation: 0.25,
          humidity: 0.2,
          dewPoint: 0.25,
        };

        try {
          // Extract relevant data (pseudo-code API structure)
          const {
            current: {
              temp: airTemp, // Temperature in Celsius
              humidity, // Relative humidity in %
              dew_point: dewPoint, // Dew point in Celsius
            },
            hourly: [
              { precipitation: recentPrecipitation }, // mm of precipitation
            ],
          } = weatherData;

          let riskScore = 0;
          const riskFactors = [];

          // Temperature risk (highest near and below freezing)
          if (airTemp <= 4) {
            const tempRisk = airTemp <= 0 ? 1 : (4 - airTemp) / 4;
            riskScore += tempRisk * RISK_WEIGHTS.temperature;
            if (tempRisk > 0.5) {
              riskFactors.push("Temperature near or below freezing");
            }
          }

          // Recent precipitation risk
          if (recentPrecipitation > 0) {
            const precipRisk = Math.min(recentPrecipitation / 5, 1);
            riskScore += precipRisk * RISK_WEIGHTS.precipitation;
            riskFactors.push("Recent precipitation detected");
          }

          // High humidity risk
          if (humidity > 70) {
            const humidityRisk = (humidity - 70) / 30;
            riskScore += humidityRisk * RISK_WEIGHTS.humidity;
            if (humidityRisk > 0.5) {
              riskFactors.push("High humidity conditions");
            }
          }

          // Dew point near freezing risk
          if (dewPoint <= 4) {
            const dewPointRisk = dewPoint <= 0 ? 1 : (4 - dewPoint) / 4;
            riskScore += dewPointRisk * RISK_WEIGHTS.dewPoint;
            if (dewPointRisk > 0.5) {
              riskFactors.push("Dew point near freezing");
            }
          }

          // Determine risk level
          let riskLevel;
          if (riskScore >= 0.7) {
            riskLevel = "HIGH";
          } else if (riskScore >= 0.4) {
            riskLevel = "MODERATE";
          } else {
            riskLevel = "LOW";
          }

          return {
            riskLevel,
            riskScore: Math.round(riskScore * 100) / 100,
            riskFactors,
            timestamp: new Date().toISOString(),
          };
        } catch (error) {
          throw new Error(
            `Failed to calculate black ice risk: ${error.message}`,
          );
        }
      }

      function determineWindEffect(windDeg, cyclingDirection) {
        // Calculate the relative angle between wind and cycling direction
        const relativeAngle = Math.abs(windDeg - cyclingDirection);

        // Wind coming from behind (tailwind): 0° ± 30°
        if (relativeAngle <= 30 || relativeAngle >= 330) {
          return "Tailwind ✅";
        }
        // Wind coming from front (headwind): 180° ± 30°
        else if (relativeAngle >= 150 && relativeAngle <= 210) {
          return "Headwind 🆘";
        }
        // All other angles are considered crosswind
        else {
          return "Crosswind 🌬️";
        }
      }

      function getWeatherIcon(weatherDescription) {
        // Convert description to lowercase for easier matching
        const desc = weatherDescription.toLowerCase();
        
        if (desc.includes('clear') || desc.includes('sunny')) {
          return '☀️';
        } else if (desc.includes('rain') || desc.includes('drizzle')) {
          return '🌧️';
        } else if (desc.includes('snow') || desc.includes('sleet')) {
          return '🌨️';
        } else if (desc.includes('thunder') || desc.includes('storm')) {
          return '⛈️';
        } else if (desc.includes('cloud')) {
          return '☁️';
        } else if (desc.includes('mist') || desc.includes('fog')) {
          return '🌫️';
        } else {
          return '❓'; // fallback for unknown weather conditions
        }
      }

      async function fetchWeatherData(
        location,
        nextLocation,
        timestamp,
        openWeatherApiKey,
      ) {
        try {
          const weatherResponse = await fetch(
            `https://api.openweathermap.org/data/2.5/onecall?lat=${location.lat()}&lon=${location.lng()}&dt=${timestamp}&appid=${openWeatherApiKey}&units=metric`,
          );

          if (!weatherResponse.ok) {
            throw new Error(`Weather API error: ${weatherResponse.status}`);
          }

          const weatherData = await weatherResponse.json();

          if (!weatherData || !weatherData.current) {
            throw new Error("Invalid weather data received");
          }

          let cyclingDirection = 0;
          if (nextLocation) {
            cyclingDirection = google.maps.geometry.spherical.computeHeading(location, nextLocation);
            cyclingDirection = (cyclingDirection + 360) % 360;
          }

          const blackIceRisk = calculateBlackIceRisk(weatherData);

          return {
            weatherIcon: getWeatherIcon(weatherData.current.weather[0].description),
            windEffect: determineWindEffect(weatherData.current.wind_deg, cyclingDirection),
            blackIceRisk
          };
        } catch (error) {
          console.error("Weather API error:", error);
          return {
            weatherIcon: '❓',
            windEffect: null,
            blackIceRisk: {
              riskLevel: "NONE",
              riskScore: 0,
              riskFactors: []
            }
          };
        }
      }

      async function getWeatherForRoute(
        route,
        departureTime,
        speed,
        openWeatherApiKey,
      ) {
        const weatherResults = [];
        const weatherCheckInterval = 5 * 60 * 1000;

        const speedValues = {
          leisurely: 20 / 3.6,
          active: 25 / 3.6,
          racing: 30 / 3.6,
        };
        const selectedSpeed = speedValues[speed] || 20 / 3.6;

        let accumulatedTime = 0;
        let currentTime = departureTime.getTime();
        let lastMarkerTime = currentTime;

        // Get weather for starting point
        const startPoint = route[0];
        const nextPoint = route[1] || null;
        const startWeather = await fetchWeatherData(
          startPoint.start_location,
          nextPoint ? nextPoint.start_location : null,
          Math.floor(currentTime / 1000),
          openWeatherApiKey,
        );

        weatherResults.push({
          position: startPoint.start_location,
          ...startWeather,
          arrivalTime: new Date(currentTime),
          distance: 0,
          step: startPoint,
          instructions: startPoint.instructions,
        });

        // Process intermediate points
        for (let i = 0; i < route.length - 1; i++) {
          const startPoint = route[i];
          const endPoint = route[i + 1];

          const distanceBetweenPoints =
            google.maps.geometry.spherical.computeDistanceBetween(
              startPoint.start_location,
              endPoint.start_location,
            );

          const travelTime = (distanceBetweenPoints / selectedSpeed) * 1000;
          accumulatedTime += travelTime;
          const arrivalTime = new Date(lastMarkerTime + accumulatedTime);

          if (accumulatedTime >= weatherCheckInterval) {
            const nextLocation =
              i + 2 < route.length ? route[i + 2].start_location : null;
            const pointWeather = await fetchWeatherData(
              endPoint.start_location,
              nextLocation,
              Math.floor(arrivalTime.getTime() / 1000),
              openWeatherApiKey,
            );

            weatherResults.push({
              position: endPoint.start_location,
              ...pointWeather,
              arrivalTime: arrivalTime,
              distance: accumulatedTime / 1000,
              step: endPoint,
              instructions: endPoint.instructions,
            });

            lastMarkerTime = arrivalTime.getTime();
            accumulatedTime = 0;
          }
        }

        // Get weather for destination point
        const finalPoint = route[route.length - 1];
        const finalArrivalTime = new Date(lastMarkerTime + accumulatedTime);
        const finalWeather = await fetchWeatherData(
          finalPoint.start_location,
          null, // No next point for the final destination
          Math.floor(finalArrivalTime.getTime() / 1000),
          openWeatherApiKey,
        );

        weatherResults.push({
          position: finalPoint.start_location,
          ...finalWeather,
          arrivalTime: finalArrivalTime,
          distance: accumulatedTime / 1000,
          step: finalPoint,
          instructions: finalPoint.instructions,
        });

        return weatherResults;
      }

      function displayRouteDetails(weatherData) {
        const output = document.getElementById("route-output");
        output.innerHTML = "";

        weatherData.forEach((point, index) => {
          const stepDiv = document.createElement("div");
          stepDiv.classList.add("route-step");

          if (point.blackIceRisk.riskLevel === "HIGH") {
            stepDiv.classList.add("risk-high");
          } else if (point.blackIceRisk.riskLevel === "MODERATE") {
            stepDiv.classList.add("risk-moderate");
          }

          let locationName = extractLocationName(point.instructions);

          // Use default checkpoint name if no location name is found
          if (!locationName) {
            locationName =
              index === 0
                ? "Starting Point"
                : index === weatherData.length - 1
                  ? "Destination"
                  : `Checkpoint ${index}`;
          }

          let iceWarning = "";
          if (
            point.blackIceRisk.riskLevel !== "LOW" &&
            point.blackIceRisk.riskLevel !== "UNKNOWN"
          ) {
            iceWarning = `
              <div class="ice-warning">
                ⚠️ Black Ice Risk: ${point.blackIceRisk.riskLevel}
                <br>
                Risk Factors: ${point.blackIceRisk.riskFactors.join(", ")}
              </div>
            `;
          }

          stepDiv.innerHTML = `
            <h3><span class="checkpoint-number">${index + 1}</span>${locationName}</h3>
            ${displayWeatherPoint(point)}
          `;
          output.appendChild(stepDiv);
        });
      }

      function displayWeatherPoint(weatherPoint) {
        return `
          <div class="weather-point">
            <div class="arrival-time">${weatherPoint.arrivalTime.toLocaleTimeString()}</div>
            <div class="weather-icon">${weatherPoint.weatherIcon}</div>
            ${weatherPoint.windEffect ? `<div class="wind-effect">${weatherPoint.windEffect}</div>` : ''}
            ${weatherPoint.blackIceRisk.riskLevel !== "NONE" ? '<div class="black-ice-warning">⛸️</div>' : ''}
          </div>
        `;
      }
    </script>
  </body>
</html>
