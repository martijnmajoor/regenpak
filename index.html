<!doctype html>
<html lang="en">
  <!-- Previous head section remains the same -->
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cycling Route Weather</title>
    <style>
      .route-step {
        margin: 20px 0;
        padding: 20px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background-color: #f9f9f9;
      }
      .route-step h3 {
        margin-top: 0;
        color: #333;
      }
      .checkpoint-number {
        display: inline-block;
        background-color: #007bff;
        color: white;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        text-align: center;
        line-height: 24px;
        margin-right: 10px;
      }
      .risk-high {
        background-color: #ffebee;
        border-color: #ef5350;
      }
      .risk-moderate {
        background-color: #fff3e0;
        border-color: #ff9800;
      }
      .ice-warning {
        margin-top: 10px;
        padding: 8px;
        border-radius: 4px;
        font-weight: bold;
      }
      .risk-high .ice-warning {
        background-color: #ef5350;
        color: white;
      }
      .risk-moderate .ice-warning {
        background-color: #ff9800;
        color: white;
      }
    </style>
  </head>
  <body>
    <!-- Previous HTML form remains the same -->
    <h1>Cycling Route Weather</h1>
    <form id="route-form">
      <label for="from">Address From:</label>
      <input type="text" id="from" name="from" required /><br />

      <label for="to">Address To:</label>
      <input type="text" id="to" name="to" required /><br />

      <label for="departure-time">Departure Time:</label>
      <input
        type="datetime-local"
        id="departure-time"
        name="departure-time"
        required
      /><br />

      <label for="speed">Cycling Speed:</label>
      <select id="speed" name="speed">
        <option value="leisurely">Leisurely (&lt;20 km/h)</option>
        <option value="active">Active (20-25 km/h)</option>
        <option value="racing">Racing/Electric (&gt;25 km/h)</option></select
      ><br />

      <label for="google-api-key">Google Maps API Key:</label>
      <input
        type="text"
        id="google-api-key"
        name="google-api-key"
        required
      /><br />

      <label for="openweather-api-key">OpenWeather API Key:</label>
      <input
        type="text"
        id="openweather-api-key"
        name="openweather-api-key"
        required
      /><br />

      <button type="submit">Get Route</button>
    </form>

    <div id="route-output"></div>

    <script>
      let googleMapsLoaded = false;

      // Previous event listeners and initialization code remains the same
      document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("from").value =
          localStorage.getItem("from") || "";
        document.getElementById("to").value = localStorage.getItem("to") || "";
        document.getElementById("speed").value =
          localStorage.getItem("cycling-speed") || "leisurely";

        const now = new Date();
        document.getElementById("departure-time").value = now
          .toISOString()
          .slice(0, 16);
      });

      document
        .getElementById("route-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          try {
            const googleApiKey =
              document.getElementById("google-api-key").value;
            const openWeatherApiKey = document.getElementById(
              "openweather-api-key",
            ).value;
            const from = document.getElementById("from").value;
            const to = document.getElementById("to").value;
            const departureTime = new Date(
              document.getElementById("departure-time").value,
            );
            const speed = document.getElementById("speed").value;

            localStorage.setItem("from", from);
            localStorage.setItem("to", to);
            localStorage.setItem("cycling-speed", speed);

            if (!googleMapsLoaded) {
              await loadGoogleMapsAPI(googleApiKey);
            }

            const route = await getRoute(from, to);
            const weatherData = await getWeatherForRoute(
              route,
              departureTime,
              speed,
              openWeatherApiKey,
            );
            displayRouteDetails(weatherData);
          } catch (error) {
            console.error("Error:", error);
            alert(`Error: ${error.message}`);
          }
        });

      // Previous API loading and route fetching functions remain the same
      async function loadGoogleMapsAPI(apiKey) {
        if (googleMapsLoaded) return;

        return new Promise((resolve, reject) => {
          const script = document.createElement("script");
          const url = new URL("https://maps.googleapis.com/maps/api/js");
          url.searchParams.append("key", apiKey);
          url.searchParams.append("libraries", "geometry");
          url.searchParams.append("v", "weekly");

          script.src = url.toString();
          script.async = true;
          script.defer = true;
          script.onerror = reject;

          script.onload = () => {
            googleMapsLoaded = true;
            resolve();
          };

          document.head.appendChild(script);
        });
      }

      function extractLocationName(instructions) {
        if (!instructions) return null;

        // Remove HTML tags
        instructions = instructions.replace(/<[^>]*>/g, "");

        // List of phrases to remove from the beginning
        const phrasesToRemove = [
          /^Head [a-z]+ on /i,
          /^Turn [a-z]+ onto /i,
          /^Turn [a-z]+ to stay on /i,
          /^Continue onto /i,
          /^Take the /i,
          /^Use the /i,
          /^Make a U-turn at /i,
          /^Slight [a-z]+ onto /i,
          /^Sharp [a-z]+ onto /i,
          /^Turn [a-z]+ at /i,
          /^Exit the roundabout onto /i,
          /^Enter the roundabout and /i,
          /^At the roundabout, /i,
        ];

        // Remove each phrase if found at the start
        phrasesToRemove.forEach((phrase) => {
          instructions = instructions.replace(phrase, "");
        });

        // If after cleaning we're left with just directional instructions, return null
        if (
          /^(Slight|Sharp|Turn|Head|Continue|Use|Take|Make|Enter|Exit) /.test(
            instructions,
          )
        ) {
          return null;
        }

        return instructions.trim();
      }

      async function getRoute(from, to) {
        return new Promise((resolve, reject) => {
          const directionsService = new google.maps.DirectionsService();
          const request = {
            origin: from,
            destination: to,
            travelMode: google.maps.TravelMode.BICYCLING,
          };

          directionsService.route(request, (result, status) => {
            if (status === "OK") {
              resolve(result.routes[0].legs[0].steps);
            } else {
              reject(new Error(`Failed to get route: ${status}`));
            }
          });
        });
      }

      // Previous weather fetching functions remain the same
      async function getWeatherForRoute(
        route,
        departureTime,
        speed,
        openWeatherApiKey,
      ) {
        const weatherResults = [];
        const weatherCheckInterval = 5 * 60 * 1000;

        const speedValues = {
          leisurely: 20 / 3.6,
          active: 25 / 3.6,
          racing: 30 / 3.6,
        };
        const selectedSpeed = speedValues[speed] || 20 / 3.6;

        let accumulatedTime = 0;
        let currentTime = departureTime.getTime();
        let lastMarkerTime = currentTime;

        // Get weather for starting point
        try {
          const startPoint = route[0];
          const timestamp = Math.floor(currentTime / 1000);
          const weatherResponse = await fetch(
            `https://api.openweathermap.org/data/2.5/onecall?lat=${startPoint.start_location.lat()}&lon=${startPoint.start_location.lng()}&dt=${timestamp}&appid=${openWeatherApiKey}`,
          );

          if (!weatherResponse.ok) {
            throw new Error(`Weather API error: ${weatherResponse.status}`);
          }

          const weatherData = await weatherResponse.json();

          if (!weatherData || !weatherData.current) {
            throw new Error("Invalid weather data received");
          }

          weatherResults.push({
            position: startPoint.start_location,
            weather: weatherData.current.weather[0].description,
            windEffect: determineWindEffect(
              weatherData.current.wind_deg,
              selectedSpeed,
            ),
            arrivalTime: new Date(currentTime),
            distance: 0,
            step: startPoint,
            instructions: startPoint.instructions,
          });
        } catch (error) {
          console.error("Weather API error for starting point:", error);
          weatherResults.push({
            position: route[0].start_location,
            weather: "Weather data unavailable",
            windEffect: "Unknown",
            arrivalTime: new Date(currentTime),
            distance: 0,
            step: route[0],
            instructions: route[0].instructions,
          });
        }

        // Process intermediate points
        for (let i = 0; i < route.length - 1; i++) {
          const startPoint = route[i];
          const endPoint = route[i + 1];

          const distanceBetweenPoints =
            google.maps.geometry.spherical.computeDistanceBetween(
              startPoint.start_location,
              endPoint.start_location,
            );

          const travelTime = (distanceBetweenPoints / selectedSpeed) * 1000;
          accumulatedTime += travelTime;
          const arrivalTime = new Date(lastMarkerTime + accumulatedTime);

          if (accumulatedTime >= weatherCheckInterval) {
            try {
              const timestamp = Math.floor(arrivalTime.getTime() / 1000);
              const weatherResponse = await fetch(
                `https://api.openweathermap.org/data/2.5/onecall?lat=${endPoint.start_location.lat()}&lon=${endPoint.start_location.lng()}&dt=${timestamp}&appid=${openWeatherApiKey}`,
              );

              if (!weatherResponse.ok) {
                throw new Error(`Weather API error: ${weatherResponse.status}`);
              }

              const weatherData = await weatherResponse.json();

              if (!weatherData || !weatherData.current) {
                throw new Error("Invalid weather data received");
              }

              weatherResults.push({
                position: endPoint.start_location,
                weather: weatherData.current.weather[0].description,
                windEffect: determineWindEffect(
                  weatherData.current.wind_deg,
                  selectedSpeed,
                ),
                arrivalTime: arrivalTime,
                distance: accumulatedTime / 1000,
                step: endPoint,
                instructions: endPoint.instructions,
              });

              lastMarkerTime = arrivalTime.getTime();
              accumulatedTime = 0;
            } catch (error) {
              console.error("Weather API error:", error);
              weatherResults.push({
                position: endPoint.start_location,
                weather: "Weather data unavailable",
                windEffect: "Unknown",
                arrivalTime: arrivalTime,
                distance: accumulatedTime / 1000,
                step: endPoint,
                instructions: endPoint.instructions,
              });

              lastMarkerTime = arrivalTime.getTime();
              accumulatedTime = 0;
            }
          }
        }

        // Get weather for destination point
        const finalPoint = route[route.length - 1];
        const finalArrivalTime = new Date(lastMarkerTime + accumulatedTime);

        try {
          const timestamp = Math.floor(finalArrivalTime.getTime() / 1000);
          const weatherResponse = await fetch(
            `https://api.openweathermap.org/data/2.5/onecall?lat=${finalPoint.start_location.lat()}&lon=${finalPoint.start_location.lng()}&dt=${timestamp}&appid=${openWeatherApiKey}`,
          );

          if (!weatherResponse.ok) {
            throw new Error(`Weather API error: ${weatherResponse.status}`);
          }

          const weatherData = await weatherResponse.json();

          if (!weatherData || !weatherData.current) {
            throw new Error("Invalid weather data received");
          }

          weatherResults.push({
            position: finalPoint.start_location,
            weather: weatherData.current.weather[0].description,
            windEffect: determineWindEffect(
              weatherData.current.wind_deg,
              selectedSpeed,
            ),
            arrivalTime: finalArrivalTime,
            distance: accumulatedTime / 1000,
            step: finalPoint,
            instructions: finalPoint.instructions,
          });
        } catch (error) {
          console.error("Weather API error for destination point:", error);
          weatherResults.push({
            position: finalPoint.start_location,
            weather: "Weather data unavailable",
            windEffect: "Unknown",
            arrivalTime: finalArrivalTime,
            distance: accumulatedTime / 1000,
            step: finalPoint,
            instructions: finalPoint.instructions,
          });
        }

        return weatherResults;
      }
      function determineWindEffect(windDeg, cyclingDirection) {
        const angleDiff = Math.abs(windDeg - cyclingDirection);

        if (angleDiff <= 30 || angleDiff >= 330) {
          return "Tailwind ✅";
        } else if (angleDiff >= 150 && angleDiff <= 210) {
          return "Headwind 🆘";
        } else {
          return "Crosswind 🌬️";
        }
      }

      function displayRouteDetails(weatherData) {
        const output = document.getElementById("route-output");
        output.innerHTML = "";

        weatherData.forEach((point, index) => {
          const stepDiv = document.createElement("div");
          stepDiv.classList.add("route-step");

          let locationName = extractLocationName(point.instructions);

          // Use default checkpoint name if no location name is found
          if (!locationName) {
            locationName =
              index === 0
                ? "Starting Point"
                : index === weatherData.length - 1
                  ? "Destination"
                  : `Checkpoint ${index}`;
          }

          stepDiv.innerHTML = `
            <h3><span class="checkpoint-number">${index + 1}</span>${locationName}</h3>
            <p><strong>Time:</strong> ${point.arrivalTime.toLocaleTimeString()}</p>
            <p><strong>Weather:</strong> ${point.weather}</p>
            <p><strong>Wind Effect:</strong> ${point.windEffect}</p>
            <p><strong>Distance:</strong> ${(point.distance / 1000).toFixed(2)} km</p>
          `;
          output.appendChild(stepDiv);
        });
      }
    </script>
  </body>
</html>
