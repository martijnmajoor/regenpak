<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cycling Route Weather</title>
    <style>
      #map {
        height: 400px;
        width: 100%;
        margin: 20px 0;
      }
      .route-step {
        margin: 20px 0;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <h1>Cycling Route Weather</h1>
    <form id="route-form">
      <label for="from">Address From:</label>
      <input type="text" id="from" name="from" required /><br />

      <label for="to">Address To:</label>
      <input type="text" id="to" name="to" required /><br />

      <label for="departure-time">Departure Time:</label>
      <input
        type="datetime-local"
        id="departure-time"
        name="departure-time"
        required
      /><br />

      <label for="speed">Cycling Speed:</label>
      <select id="speed" name="speed">
        <option value="leisurely">Leisurely (&lt;20 km/h)</option>
        <option value="active">Active (20-25 km/h)</option>
        <option value="racing">Racing/Electric (&gt;25 km/h)</option></select
      ><br />

      <label for="google-api-key">Google Maps API Key:</label>
      <input
        type="text"
        id="google-api-key"
        name="google-api-key"
        required
      /><br />

      <label for="openweather-api-key">OpenWeather API Key:</label>
      <input
        type="text"
        id="openweather-api-key"
        name="openweather-api-key"
        required
      /><br />

      <button type="submit">Get Route</button>
    </form>

    <div id="map"></div>
    <div id="route-output"></div>

    <script>
      let map;
      let markers = [];
      let polyline;
      let googleMapsLoaded = false;

      document.addEventListener("DOMContentLoaded", () => {
        // Load saved values from localStorage
        document.getElementById("from").value =
          localStorage.getItem("from") || "";
        document.getElementById("to").value = localStorage.getItem("to") || "";
        document.getElementById("speed").value =
          localStorage.getItem("cycling-speed") || "leisurely";

        // Set default departure time to current timestamp
        const now = new Date();
        document.getElementById("departure-time").value = now
          .toISOString()
          .slice(0, 16);
      });

      document
        .getElementById("route-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          try {
            const googleApiKey =
              document.getElementById("google-api-key").value;
            const openWeatherApiKey = document.getElementById(
              "openweather-api-key",
            ).value;
            const from = document.getElementById("from").value;
            const to = document.getElementById("to").value;
            const departureTime = new Date(
              document.getElementById("departure-time").value,
            );
            const speed = document.getElementById("speed").value;

            localStorage.setItem("from", from);
            localStorage.setItem("to", to);
            localStorage.setItem("cycling-speed", speed);

            if (!googleMapsLoaded) {
              await loadGoogleMapsAPI(googleApiKey);
            }

            const route = await getRoute(from, to);
            const weatherData = await getWeatherForRoute(
              route,
              departureTime,
              speed,
              openWeatherApiKey,
            );
            displayRouteOnMap(route, weatherData);
            displayRouteDetails(weatherData);
          } catch (error) {
            console.error("Error:", error);
            alert(`Error: ${error.message}`);
          }
        });

      async function loadGoogleMapsAPI(apiKey) {
        if (googleMapsLoaded) return;

        return new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=geometry&callback=initMap`;
          script.async = true;
          script.defer = true;
          script.onerror = reject;
          window.initMap = () => {
            map = new google.maps.Map(document.getElementById("map"), {
              zoom: 12,
              center: { lat: 0, lng: 0 },
            });
            googleMapsLoaded = true;
            resolve();
          };
          document.head.appendChild(script);
        });
      }

      function clearMap() {
        // Clear existing markers
        markers.forEach((marker) => marker.setMap(null));
        markers = [];

        // Clear existing polyline
        if (polyline) {
          polyline.setMap(null);
        }
      }

      async function getRoute(from, to) {
        return new Promise((resolve, reject) => {
          const directionsService = new google.maps.DirectionsService();
          const request = {
            origin: from,
            destination: to,
            travelMode: google.maps.TravelMode.BICYCLING,
          };

          directionsService.route(request, (result, status) => {
            if (status === "OK") {
              resolve(result.routes[0].legs[0].steps);
            } else {
              reject(new Error(`Failed to get route: ${status}`));
            }
          });
        });
      }

      async function getWeatherForRoute(route, departureTime, speed, openWeatherApiKey) {
  const weatherResults = [];
  const weatherCheckInterval = 5 * 60 * 1000; // 5 minutes in milliseconds

  // Convert speed to meters per second
  const speedValues = {
    leisurely: 20 / 3.6, // Convert km/h to m/s
    active: 25 / 3.6,
    racing: 30 / 3.6,
  };
  const selectedSpeed = speedValues[speed] || 20 / 3.6; // m/s

  let accumulatedTime = 0; // Time accumulated as we move through the route
  let currentTime = departureTime.getTime(); // Departure time in milliseconds
  let lastMarkerTime = currentTime;

  // Start with a marker at the departure point
  weatherResults.push({
    position: route[0].start_location,
    weather: "Starting point",
    windEffect: "Unknown",
    arrivalTime: new Date(currentTime),
    distance: 0,
    step: route[0],
  });

  for (let i = 0; i < route.length - 1; i++) {
    const startPoint = route[i];
    const endPoint = route[i + 1];

    // Calculate the distance between consecutive points (in meters)
    const distanceBetweenPoints = google.maps.geometry.spherical.computeDistanceBetween(
      startPoint.start_location, 
      endPoint.start_location
    );

    // Calculate travel time between points (in milliseconds)
    const travelTime = (distanceBetweenPoints / selectedSpeed) * 1000; // Time in ms

    // Accumulate travel time
    accumulatedTime += travelTime;

    // If the time between the current and next point is greater than 5 minutes, create intermediate markers
    if (accumulatedTime > weatherCheckInterval) {
      const numIntervals = Math.floor(accumulatedTime / weatherCheckInterval);

      // Create intermediate markers
      for (let j = 0; j < numIntervals; j++) {
        const intermediateTime = lastMarkerTime + j * weatherCheckInterval;
        const intermediateArrivalTime = new Date(intermediateTime);

        const progressRatio = (j + 1) / (numIntervals + 1); // Ratio to interpolate positions
        const intermediateLat = startPoint.start_location.lat() + (endPoint.start_location.lat() - startPoint.start_location.lat()) * progressRatio;
        const intermediateLng = startPoint.start_location.lng() + (endPoint.start_location.lng() - startPoint.start_location.lng()) * progressRatio;

        try {
          const timestamp = Math.floor(intermediateArrivalTime.getTime() / 1000); // Timestamp in seconds
          const weatherResponse = await fetch(
            `https://api.openweathermap.org/data/2.5/onecall?lat=${intermediateLat}&lon=${intermediateLng}&dt=${timestamp}&appid=${openWeatherApiKey}`
          );

          if (!weatherResponse.ok) {
            throw new Error(`Weather API error: ${weatherResponse.status}`);
          }

          const weatherData = await weatherResponse.json();

          if (!weatherData || !weatherData.current) {
            throw new Error("Invalid weather data received");
          }

          // Add the weather result to the array
          weatherResults.push({
            position: new google.maps.LatLng(intermediateLat, intermediateLng),
            weather: weatherData.current.weather[0].description,
            windEffect: determineWindEffect(weatherData.current.wind_deg, selectedSpeed),
            arrivalTime: intermediateArrivalTime,
            distance: accumulatedTime / 1000, // Convert to km
            step: { start_location: new google.maps.LatLng(intermediateLat, intermediateLng) },
          });

        } catch (error) {
          console.error("Weather API error:", error);
          weatherResults.push({
            position: new google.maps.LatLng(intermediateLat, intermediateLng),
            weather: "Weather data unavailable",
            windEffect: "Unknown",
            arrivalTime: intermediateArrivalTime,
            distance: accumulatedTime / 1000, // Convert to km
            step: { start_location: new google.maps.LatLng(intermediateLat, intermediateLng) },
          });
        }
      }
    }

    // Now create the marker for the destination point
    const arrivalTime = new Date(lastMarkerTime + accumulatedTime);
    weatherResults.push({
      position: endPoint.start_location,
      weather: "Destination reached",
      windEffect: "Unknown",
      arrivalTime: arrivalTime,
      distance: accumulatedTime / 1000, // Convert to km
      step: endPoint,
    });

    lastMarkerTime = arrivalTime.getTime(); // Update the last marker time
    accumulatedTime = 0; // Reset accumulated time for next segment
  }

  return weatherResults;
}

      function calculateDirection(start, end) {
        const lat1 = (Math.PI / 180) * start.lat;
        const lat2 = (Math.PI / 180) * end.lat;
        const deltaLng = (Math.PI / 180) * (end.lng - start.lng);

        const y = Math.sin(deltaLng) * Math.cos(lat2);
        const x =
          Math.cos(lat1) * Math.sin(lat2) -
          Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLng);

        return ((Math.atan2(y, x) * 180) / Math.PI + 360) % 360;
      }

      function determineWindEffect(windDeg, cyclingDirection) {
        const angleDiff = Math.abs(windDeg - cyclingDirection);

        if (angleDiff <= 30 || angleDiff >= 330) {
          return "Tailwind ✅";
        } else if (angleDiff >= 150 && angleDiff <= 210) {
          return "Headwind 🆘";
        } else {
          return "Crosswind 🌬️";
        }
      }

      function displayRouteOnMap(route, weatherData) {
        clearMap();

        // Create path coordinates for the entire route
        const path = [];
        route.forEach((step) => {
          // Add decoded path points if available
          if (step.path) {
            path.push(...step.path);
          } else {
            // Fallback to start and end points
            path.push(step.start_location);
          }
        });
        // Add final endpoint
        if (route.length > 0) {
          path.push(route[route.length - 1].end_location);
        }

        // Draw the route
        polyline = new google.maps.Polyline({
          path: path,
          geodesic: true,
          strokeColor: "#FF0000",
          strokeOpacity: 1.0,
          strokeWeight: 2,
          map: map,
        });

        // Add markers for weather checkpoints
        weatherData.forEach((point, index) => {
          const marker = new google.maps.Marker({
            position: point.position,
            map: map,
            title: `Weather Checkpoint ${index + 1}`,
            label: (index + 1).toString(),
          });

          // Add info window
          const infoWindow = new google.maps.InfoWindow({
            content: `
                        <div>
                            <p><strong>Time:</strong> ${point.arrivalTime.toLocaleTimeString()}</p>
                            <p><strong>Weather:</strong> ${point.weather}</p>
                            <p><strong>Wind Effect:</strong> ${point.windEffect}</p>
                            <p><strong>Distance:</strong> ${(point.distance / 1000).toFixed(2)} km</p>
                        </div>
                    `,
          });

          marker.addListener("click", () => {
            infoWindow.open(map, marker);
          });

          markers.push(marker);
        });

        // Fit the map to show all markers
        if (path.length > 0) {
          const bounds = new google.maps.LatLngBounds();
          path.forEach((point) => bounds.extend(point));
          map.fitBounds(bounds);
        }
      }

      function displayRouteDetails(weatherData) {
        const outputDiv = document.getElementById("route-output");
        outputDiv.innerHTML = "<h3>Weather Checkpoints:</h3>";

        weatherData.forEach((point, index) => {
          const div = document.createElement("div");
          div.className = "route-step";
          div.innerHTML = `
                    <h4>Checkpoint ${index + 1}</h4>
                    <p><strong>Distance:</strong> ${(point.distance / 1000).toFixed(2)} km</p>
                    <p><strong>Arrival Time:</strong> ${point.arrivalTime.toLocaleTimeString()}</p>
                    <p><strong>Weather:</strong> ${point.weather}</p>
                    <p><strong>Wind Effect:</strong> ${point.windEffect}</p>
                `;
          outputDiv.appendChild(div);
        });
      }
    </script>
  </body>
</html>
